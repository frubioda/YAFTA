\documentclass[12pt,preprint]{aastex}

\begin{document} 

\title{Feature Tracking with YAFTA} 
%
\par
\noindent
Feature tracking amounts to, essentially, two tasks: 
\begin{enumerate}
\item identifying features in an image; and 
\item matching identified features between images.
\end{enumerate}

\noindent
Making feature tracking useful to answer scientific 
questions imposes an additional task:
\begin{enumerate}
\item[3.] analysis of tracking results.
\end{enumerate}

\noindent
\textsc{YAFTA} (Yet Another Feature Tracking Algorithm) is a suite of
IDL programs that accomplishes these tasks using an
intuitive, modular approach.  Though relatively simple, these routines
can appear complex to new users.  This document aims familiarize the
uninitiated with their use.  Below, I first outline how each of these
three tasks are accomplished, in general terms; then I give specific examples.

The code, supporting software, and electronic versions of this 
documentation can be downloaded from 
\textsl{http://solarmuri.ssl.berkeley.edu/$\sim$welsch/public/software/YAFTA/} 
~.

\section{Identifying Features}

\noindent
``Features'' are collections of pixels in a 2-D, ($N_x, N_y$) image
array that are grouped according to some criterion.  \textsc{YAFTA} is
optimized for application to magnetograms (line-of-sight, as in Figure
\ref{fig:data}, or the normal component of vector magnetograms), and
groups collections of pixels together that are {\em convex} in
absolute field strength.  Simply put, pixels that lie on the same
``hills'' in absolute field strength are grouped together.  (Pixels
lying on saddle points are grouped with pixels in the direction of the
steepest uphill gradient.)

% 1
\begin{figure}
\plotone{data.eps}
\caption{This constrast-enhanced, grayscale sub-image of an MDI
full-disk, line-of-sight magnetogram, taken on 10 May 1997 at 00:04:05
UT, shows the large, positive-flux (white) sunspot in AR 8038, and
nearby weaker, negative flux concentrations (black). 
This figure was generated by \textsc{YAFTA\_display.pro} (see Table 
\ref{tab:sftwr}), using the command ``YAFTA\_display,image,/aspect''.
\label{fig:data}}
\end{figure}
%

\noindent
This grouping is accomplished with a flux-ranked, downhill labelling
algorithm (Welsch and Longcope 2003), \nocite{Welsch2003}
\textsc{rankdown.pro}, which generates a label mask.  A label mask is an
($N_x, N_y$) array in which the pixels bear the label of the feature,
if any, with which each pixel has been grouped.  Pixels below a
user-set threshold in flux density are not grouped, and receive a zero
label in the mask.  \textsc{YAFTA} uses signed masks: the labels in
the mask bear the sign of the magnetic flux of the pixels in the
group, as in Figure \ref{fig:mask}.  The IDL routine
\textsc{label\_region.pro} can also be used to group contiguous pixels
--- i.e., all positive-flux pixels above threshold that touch each
other.

% 2
\begin{figure}
\plotone{mask.eps}
\caption{A mask of pixels from the magnetogram image Figure
\ref{fig:data} grouped by convexity with \textsc{rankdown.pro}.
Pixels below a 30G threshold in absolute flux density were not
labelled.  Negative (positive) pixels' labels are shown in white
(black) for contrast.  The minimum absolute flux density threshold passed to
\textsc{rankdown.pro} is user-set.  
This figure was generated using the IDL routines \textsc{YAFTA\_display.pro}
and \textsc{display\_labels.pro} (see Table \ref{tab:sftwr}), using the
commands ``YAFTA\_display,image,/aspect'' and ``display\_labels,image,mask''.
\label{fig:mask}}
\end{figure}
%

\noindent
After grouping pixels into features, \textsc{create\_features.pro}
analyzes groupings that match given criteria (minimum number of
pixels, or peak field strength above a ``peak threshold''), computes
various quantities (detailed in Table \ref{tab:strct}) to characterize
each such feature, and stores these quantities in an IDL structure
associated with that feature.  All the features' structures from a
given step are concatenated in a 1-D array of structures.  Figure
\ref{fig:label1} shows features identified from the mask shown in
Figure \ref{fig:mask}.

% 3
\begin{figure}
\plotone{label1.eps}
\caption{Flux elements, defined by \textsc{create\_features.pro}, are
outlined by colored contours, with their numerical labels plotted at
their magnetic centers-of-flux.  Note that pixel groupings identified
in Figure \ref{fig:mask} with less than 10 pixels are not identified
as features.  (The minimum-size threshold passed to
\textsc{create\_features.pro} is user-set.) The negative flux identified
as features 22 and 24 probably results from a projection effect --- AR
8038 lies to the east of disk center, and the penumbral field of its
spot (feature 1) points away from the instrument, and lies essentially
tangential to the solar surface. 
This figure was generated using the IDL routines \textsc{YAFTA\_display.pro}
\textsc{plot\_edges.pro}, and \textsc{plot\_labels.pro} (see Table
\ref{tab:sftwr}), using the commands ``YAFTA\_display,image,/aspect'',
``plot\_edges,mask'', and ``plot\_labels,features''.
\label{fig:label1}}
\end{figure}
%

\section{Matching Features}

\noindent
Matching of features between two successive images is accomplished
with \linebreak[4] \textsc{match\_features\_v*.pro}, which uses
overlapping pixels from each image's mask, and the array of structures
from each image, to match features.  Features can fragment, merge,
appear, and disappear.  (While, ideally, each positive-flux feature
would appear or disappear simultaneously with a an equal amount of
negative flux, in practice unipolar features are often observed to
appear or disappear without any nearby oppositely-signed counterpart
[see Lamb and DeForest 2004].  \nocite{Lamb2004}
This might arise from the coalescence or dispersal of flux
across the magnetograph threshold.)

\noindent
In the matching process, the labels stored in features' structures in
the current time step are changed, as are the corresponding pixels
in that time step's mask, via association with features from the
previous step.  Figure \ref{fig:label2} shows features identified from
the next image in the MDI sequence, and Figure \ref{fig:match2} shows
the relabelled figures after matching with the features in Figure
\ref{fig:label1}.

\noindent
Each feature's ``source'' and ``terminous'' are recorded in the .src
and .trm fields, respectively, of that feature's structure (see Table
\ref{tab:strct}).  During the matching process at a given step, both
the .src fields from the current step's features and the .trm fields
from the previous step's features are updated.  Features that do not
appear, disappear, fragment, or merge, between steps are termed
``one-to-one'' matches.  These features ``propagate'' themselves:
their .label, .src, and .trm fields are identical.

\noindent
Usually (depending upon image cadence), most features are matched
one-to-one between steps.  When a feature fragments into more than one
``child,'' the largest child (by absolute flux) keeps the label of the
``parent.''  An analogous procedure is used when many parent features
merge into one child: the label of that parent with the greatest flux
is passed on to the single child.  Figures \ref{fig:label1} and
\ref{fig:match2} show that features 15 and 11, for instance, have
merged.


% 4
\begin{figure}
\plotone{label2.eps} 
\caption{Features identified in the corresponding sub-region of the
next MDI full-disk magnetogram, taken 96 minutes later.  These
features have not been matched with those in Figure \ref{fig:label1}.
\label{fig:label2}}
\end{figure}
%

% 5
\begin{figure}
\plotone{match2.eps}
\caption{Relabelled features from Figure \ref{fig:label2} after
applying \textsc{match\_features\_v01.pro}, to identify correspoding
features between Figures \ref{fig:label1} and \ref{fig:label2}.
Comparison of this image with Figure \ref{fig:label2} shows that some
features remain essentially unchanged (2,3,21, etc.), while others
merge (e.g., 15 and 11), appear (27), or disappear (5, 26).  No
features fragment over this time interval.  The slow image cadence
has allowed relatively large changes in the features' structures to occur
between tracking steps.
\label{fig:match2}}
\end{figure}
%

\noindent
Because the matching process is complex, modifications to the feature
matching routine are likely.  Hence, each version of this routine
carries a version number: \textsc{match\_features\_v01.pro,
match\_features\_v02.pro}, denoted here by
\textsc{match\_features\_v*.pro}, etc.

\section{Analyzing Tracking Results}

\noindent
Feature tracking results can be analyzed in many ways, so I only
present a few examples here.  In Table \ref{tab:sftwr}, I list the
codes used directly for tracking, and some codes that are useful for displaying
results.  (Comment lines in these codes give examples of their use.)
In order for these codes to run correctly, IDL must call these 
non-standard routines, so make sure these routines are in the file
path IDL will search.  In Table \ref{tab:strct}, I describe the
quantities stored by \textsc{create\_features.pro} for each feature at
each time step.

\noindent
I have also provided several IDL files for tutorial purposes.  The
main level IDL code \textsc{YAFTA\_test.pro} loads in data from
\textsc{YAFTA\_input.sav}, and runs the tracking routines, and
generates the output data stored in \textsc{YAFTA\_output.sav}.  By
restoring \textsc{YAFTA\_output.sav}, one can emulate the commands
below.  To facilitate entering these commands in IDL, I have stored
them in a separate file, \textsc{YAFTA\_IDL.pro}, stripped of any text
except for comment lines.  


\begin{list}{$\bullet$}{}
%
\item To find the structures associated with a feature, say the
feature labelled \# 8, and plot the feature's unsigned flux as a function of
time, one could use
%
\par
\indent IDL$>$ index8 = where(features.label eq 8, n8) \\
\indent IDL$>$ if n8 ne 0 then flux8 = features(index8).phi \\
\indent IDL$>$ if n8 ne 0 then step8 = features(index8).step \\
\indent IDL$>$ if n8 ne 0 then plot, step8, flux8  \\
\par
%
This could be done another way with less code,
%
\par
\indent IDL$>$ index8 = where(features.label eq 8, n8) \\
\indent IDL$>$ if n8 ne 0 then feat8 = features(index8) \\
\indent IDL$>$ if n8 ne 0 then plot, feat8.step, feat8.phi  \\
\par
%
To plot the signed flux, one can multiply the .phi field by the .sign
field,
%
\par
\indent IDL$>$ if n8 ne 0 then plot, feat8.step, feat8.phi*feat8.sign  \\
\par
%
\item A feature that first appears at step $t = k$ where no features
previously existed (and is therefore not a result of fragmentation
[see below]) has $-k$ in its source field.  (All features from the
initial tracking step have .src set to 0.)  Analogously, features that
disappear at a step $t = k$ have .trm set to $-k$.  (All features from
the final tracking step have .trm set to 0.)  To find appearances, and
calculate their contribution to the average flux (excluding all
features from the first step), one could use
%
\par 
\indent IDL$>$ apps = where(features.src lt 0, n\_apps) \\ 
\indent IDL$>$ if n\_apps ne 0 then appflux = total(features(apps).phi)  \\
\indent IDL$>$ notfirst = features(where(features.step gt 0)) \\
\indent IDL$>$ if n\_apps ne 0 then flux = total(notfirst.phi) \\
\indent IDL$>$ if n\_apps ne 0 then print, appflux, flux \\
%
\item 
A feature at step $t = k$ that derived from a feature from step $t =
k-1$ (either as a one-to-one match, or as a fragment) has the label of
the feature from $t = k-1$ in its .src field.  In a fragmentation, though,
only the largest fragment (by flux) keeps its .src label, so
fragments can be found by searching for .src fields that are positive
and differ from .label fields.  (Recall that all features from the
initial step have a zero in their .src fields!)  So, to find the
average unsigned flux contained in a fragment, use:
%
\par
\indent IDL$>$ where\_frag = where(features.label ne features.src and \$ \\
\indent IDL$>$ features.src gt 0) \\
\indent IDL$>$ if n\_frags ne 0 then frags = features(where\_frag) \\
\indent IDL$>$ if n\_frags ne 0 then fragflux = total(frags.phi)/n\_frags \\
\par
This can be compared to the average unsigned flux of all elements, 
%
\par
\indent IDL$>$ avgflux= total(features.phi)/n\_elements(features.phi) \\
\indent IDL$>$ print,'Avg. Unsigned Flux in All Features, in Fragments:' \\
\indent IDL$>$ print,avgflux,fragflux \\
%
\item The 1-D pixel addresses of each feature are also stored in that
feature's structure (as a string variable), and can be used to
visualize a feature's shape at a given step.
%
\par
\indent IDL$>$ mask\_str = features(13).mask\_str  \\
\indent IDL$>$ addresses = long(strsplit(mask\_str,/extract)) \\
\indent IDL$>$ newmask = all\_masks(*,*,0) \\
\indent IDL$>$ newmask(*,*) = 0 \\
\indent IDL$>$ newmask(addresses) = 13 \\
\indent IDL$>$ YAFTA\_display, img, /aspect \\
\indent IDL$>$ plot\_edges, newmask \\
\par
%
This ``feature mask'' can also be visualized in isolation,
%
\par
\indent IDL$>$ YAFTA\_display, newmask, /asp \\
%
\par
and even dilated, using IDL's DILATE.PRO,
%
\par
\indent IDL$>$ dilmask = newmask \\
\indent IDL$>$ dilmask(addresses) = 10 \\
\indent IDL$>$ s1 = replicate(1,3,3) ; dilates to nearest neighbors \\
\indent IDL$>$ dilate1 = 9*fix(dilate(dilmask, s1)) \\
\indent IDL$>$ s2 = replicate(1,5,5) ; dilates to 2 nearest neighbors \\
\indent IDL$>$ dilate2 = 8*fix(dilate(dilmask, s2)) \\
\indent IDL$>$ YAFTA\_display, dilmask+dilate1+dilate2, /asp \\
\indent IDL$>$ plot\_edges, newmask \\
\par
%
\end{list}

\noindent
One useful application of \textsc{YAFTA} (and feature tracking in
general) is to study the process of cancellation.  Perhaps the first
step in using \textsc{YAFTA} for cancellation analysis is to determine
when cancellation is occurring.  The IDL program
\textsc{find\_nearby.pro} provides a potentially useful scheme, as
outlined below, for finding closely spaced pairs of oppositely signed
features.

%
\begin{enumerate}
%
\item Input the array of feature structures and mask from one or more
time steps.
%
\item For each time step, construct a ``dilated mask'' of negative
features, using IDL's DILATE.PRO to dilate the mask of each negative
feature, and combining them into a single mask.  The number of pixels
by which to dilate is a free parameter.
%
\item (Since dilated feature masks can overlap with masks from other
features [dilated or otherwise], pixel labels that conflict with
previously assigned labels are not assigned.)
% 
\item Loop over all positive-flux features from the same time step. 
%
\item In the loop, dilate each feature's mask, and multiply the result
by the dilated negative mask.  If the product array of the dilated
masks contains non-zero elements, then the masks overlap, and
overlapping labels and pixels are found.
%
\item Record either the indices (default) or labels of the overlapping
features in one array, and the corresponding overlapping pixel
addresses (as character strings) in another.
%
\end{enumerate}
%
This routine only {\em identifies} cases in which the dilated masks
overlap; determining whether cancellation actually occurred during
that step or not is a different matter.  Other criteria for
cancellation need to be applied at this point, e.g.,
\begin{list}{$\circ$}{}
%
\item Do the features' absolute fluxes decline at that step?  If so,
by how much?  
%
\item Do the features' centers-of-flux approach each other?  
%
\end{list}
%
Notably, both of these criteria can be undermined by evolution away
from the site of overlap --- e.g., by merging with a same-sign feature
away from the overlapping region.  Further analysis of cancellation
requires more detailed examination of the features identified by
\textsc{find\_nearby.pro}.  

\section{Known Problems \& Bugs}

New users should be aware of these programs' potential shortcomings.

\begin{enumerate}

\item When run at the main program level (as in \textsc{YAFTA\_test.pro}),
these routines create variables that are not destroyed after program
completion.  Consequently, errors can be encountered running these
procedures repeatedly in the same IDL session without first deleting or
renaming variables.  ALternatively, these programs can be incorporated in
a procedure, which will destroy local variables upon completion.

\item A bug exists on some architectures (so far, only DEC stations), in
which IDL will not concatenate anonymous structures with identical fields,
as done in \textsc{create\_features.pro}.  One easy work around is to us
named structures instead.  To do so, modify one line of code in
\textsc{create\_features.pro}, replacing

\[ \mbox{feature} = \mbox{\{label:label\_j,} \cdots \]

with 

\[ \mbox{feature} = \mbox{\{feature,label:label\_j,} \cdots \]


\end{enumerate}



\begin{minipage}[t]{6.0in}
\begin{tabular}{|l|l|} \hline \label{tab:strct} 
  {\bf Field}
& {\bf Content} \\ \hline
%
label & longword integer label, $i$; changes when matching occurs \\ \hline
%
size & integer \# of pixels grouped into feature $i$ \\ \hline 
%
step & integer tracking step at which this structure was created \\ \hline
%
src & integer, $i$'s source, from matching: if negative, appeared at 
step (-src); \\
& if positive, label of parent feature from previous step
\footnote{\footnotesize 
Parent-child .src fields are identical for one-to-one matches, 
but differ when a parent fragments into $M>1$ children.}
\\ \hline
%
trm & integer, $i$'s terminus, from matching: if negative, disappeared at \\ 
& step (-src); if positive, label of child feature from next step 
\protect
\footnote{\footnotesize
Parent-child .trm fields are identical for one-to-one matches, 
but differ when $M>1$ parents merge into one child.}  
\\ \hline
%
sign & integer +/- 1 gives $i$'s polarity \\ \hline
%
phi & abs(signal) $\times$ pixel area, \, $dA$, summed over $i$'s
$N_i$ pixels, \\
& $\Phi_i = (\sum_{j=1}^{N_i} |B_j|) dA $ \\ \hline
%
maxb & absolute max. field in feature; useful for dual thresholding \\ \hline
%
x & $i$'s flux-weighted average $x$ coord., $x_i = (\sum_{j=1}^{N_i} x_j
B_j) dA/ \Phi_i$ \\ \hline
%
y & $i$'s flux-weighted average $x$ coord., $y_i = (\sum_{j=1}^{N_i} y_j
B_j) dA/ \Phi_i$ \\ \hline
%
mask\_str & string variable containing feature's pixel addresses, 
retrieve via \\
& addresses = long(strsplit(mask\_str,/extract)) in IDL \\ \hline
%
x2 & 2nd moment of spatial distribution, \\
& $x2_i = (\sum_{j=1}^{N_i} (x_i - x_j)^2 B_j) dA/ \Phi_i$ \\ \hline
%
y2 & 2nd moment of spatial distribution, \\
& $y2_i = (\sum_{j=1}^{N_i} (y_i - y_j)^2 B_j) dA/ \Phi_i$ \\ \hline
%
xy & 2nd moment of spatial distribution, \\
& $xy_i = (\sum_{j=1}^{N_i} (x_i - x_j) (y_i - y_j) B_j) dA/ \Phi_i$ \\ \hline
%
vx &  given LCT velocities, vx is $i$'s avg. horizontal velocity, \\
& $vx_i = (\sum_{j=1}^{N_i} vx_j B_j) dA/ \Phi_i$ \\ \hline
%
vx2 & given LCT velocities, $vx2_i = (\sum_{j=1}^{N_i} (vx_i - vx_j)^2
B_j) dA/ \Phi_i$ \\ \hline
%
vy & given LCT velocities, vy is $i$'s avg. vertical velocity, \\
& $vy_i = (\sum_{j=1}^{N_i} vy_j B_j) dA/ \Phi_i$ \\ \hline
%
vy2 & given LCT velocities, $vy2_i = (\sum_{j=1}^{N_i} (vy_i - vy_j)^2
B_j) dA/ \Phi_i$ \\ \hline
%
vxvy & given LCT velocities, \\
& $vxvy_i = (\sum_{j=1}^{N_i} (vx_i - vx_j)
(vy_i - vy_j) B_j) dA/ \Phi_i$ \\ \hline
\end{tabular}
\end{minipage}



\noindent

\begin{tabular}{|l|l|} \hline \label{tab:sftwr}
  {\bf IDL Program}
& {\bf Purpose} \\ \hline
%
\textsc{rankdown.pro} 
& groups pixels (by convexity) into features, \\
& generates mask \\ \hline
%
\textsc{pad\_array.pro} 
& called by \textsc{rankdown.pro}, pads an input \\ 
& array with rows and columns of zeros
\\ \hline
%
\textsc{create\_features.pro} 
& analyzes features, creates structure for each \\ \hline
%
\textsc{match\_featuresv\_01.pro} 
& matches features between time steps \\ \hline
%
\textsc{YAFTA\_display.pro} 
& a renamed copy of \textsc{display.pro}, a wrapper for IDL's \\
& \textsc{tvscl.pro}; generates images (with titles, proper \\
& aspect ratio, etc.) easily \\ \hline 
%
\textsc{imgscl\_fen.pro} 
& called by \textsc{YAFTA\_display.pro} \\ \hline
%
\textsc{imgexp.pro} 
&  called by \textsc{YAFTA\_display.pro} \\ \hline
\textsc{display\_labels.pro} 
& overlays mask's labels, via xyouts, \\
& on displayed image \\ \hline
%
\textsc{tvread.pro} 
& reads current IDL window into various graphics \\
& file formats
\\ \hline 
%
\textsc{plot\_edges.pro} 
& overlays features' outlines, colored by label, \\
& on displayed image \\ \hline
\textsc{plot\_labels.pro} 
& overlays features' labels, colored by label, \\
& on displayed image \\ \hline
%
\textsc{find\_cancel.pro} 
& analyzes \textsc{YAFTA} results to find cancellations, \\
& and estimates cancelled flux \\ \hline
%
\textsc{YAFTA\_input.sav} 
& IDL save file of MDI full-disk images of AR 8038, \\
& to test \textsc{YAFTA} 
\\ \hline
%
\textsc{YAFTA\_test.pro} 
& main level IDL routine that tracks data from \\
& \textsc{YAFTA\_input.sav}, and stores results \\
& in \textsc{YAFTA\_output.sav}  \\ \hline
%
\textsc{YAFTA\_output.sav} 
& IDL save file generated by \textsc{YAFTA\_test.pro}
\\ \hline
%
\textsc{YAFTA\_IDL.pro} 
& main level IDL code, extracted from text of this \\
& document, for easily entering IDL commands above \\ \hline
\end{tabular}

% DONE:
%======
% RANKDOWN.PRO
% CREATE_FEATURES.PRO
% display.pro
% imgscl_fen.pro
% imgexp.pro
% tvread.pro
% display_labels.pro
% plot_edges.pro
% plot_labels.pro
%
% TO DO:
%=======
% ? - bg_vect.pro 
% test_track.pro
%



\bibliographystyle{/home/welsch/Latfiles/apj_exact}
\bibliography{/home/welsch/Latfiles/abbrevs,/home/welsch/Latfiles/short_abbrevs,/home/welsch/Latfiles/full_lib,/home/welsch/Latfiles/bib_mods}





\end{document}
